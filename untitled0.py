# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b8InvtDoribWzk8LTKxbc0IODbDp0xSL
"""

!pip install requests feedparser beautifulsoup4 yfinance python-telegram-bot nest_asyncio

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 1) Credenciais (seu TOKEN e chat_id)
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
TELEGRAM_TOKEN = '8294596491:AAGyzS8sVFhFmR4wOyS__jD_iGBEEjzF-go'
CHAT_ID        = 1040590608  # sem aspas, Ã© inteiro

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 2) Imports e setup
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
import os
import time
import asyncio
import requests
import feedparser
from bs4 import BeautifulSoup
from datetime import datetime, timedelta

from telegram import Bot
from telegram.constants import ParseMode
from telegram.error import TelegramError

import yfinance as yf
import nest_asyncio
nest_asyncio.apply()

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 3) Instanciar o bot (sem parse_mode aqui)
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
bot = Bot(token=TELEGRAM_TOKEN)

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 4) URLs de fontes
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
RSS_FEEDS = ['https://www.investing.com/rss/news.rss']
CAL_USA   = 'https://br.investing.com/economic-calendar/Service/RssHandler.ashx?country=1'
CAL_BRA   = 'https://br.investing.com/economic-calendar/Service/RssHandler.ashx?country=25'

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 5) FunÃ§Ãµes auxiliares
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
def fetch_rss_news():
    now = datetime.utcnow()
    items = []
    for url in RSS_FEEDS:
        feed = feedparser.parse(url)
        for entry in feed.entries:
            published = datetime(*entry.published_parsed[:6])
            if now - published < timedelta(minutes=5):
                items.append({
                    'title': entry.title,
                    'link': entry.link,
                    'published': published
                })
    return items

def fetch_macro_events():
    events = []
    for url in (CAL_USA, CAL_BRA):
        r = requests.get(url)
        soup = BeautifulSoup(r.content, 'xml')
        for item in soup.find_all('item'):
            impact = item.find('impact')
            if impact and impact.text.lower() == 'high':
                events.append({
                    'title':    item.title.text,
                    'pubDate':  datetime.strptime(item.pubDate.text, '%a, %d %b %Y %H:%M:%S GMT'),
                    'link':     item.link.text,
                    'forecast': item.find('forecast').text,
                    'previous': item.find('previous').text
                })
    return events

def validate_move(ticker, t0, window_sec):
    hist = yf.Ticker(ticker).history(period='1d', interval='1m')
    p0   = hist.loc[t0.strftime('%Y-%m-%d %H:%M')]['Close']
    time.sleep(window_sec)
    hist2 = yf.Ticker(ticker).history(period='1d', interval='1m')
    p1    = hist2.loc[(t0 + timedelta(seconds=window_sec)).strftime('%Y-%m-%d %H:%M')]['Close']
    return p0, p1

def format_event(ev):
    ts = ev['pubDate'].strftime('%d/%m %H:%M')
    msg = (
        f"ğŸ•’ *{ts}*  â—ï¸ HIGH IMPACT ğŸ‚ğŸ‚ğŸ‚\n"
        f"{ev['title']}\n"
        f"Forecast: {ev['forecast']} | Previous: {ev['previous']}\n"
        f"[Investing]({ev['link']})\n"
    )
    if 'Payrolls' in ev['title']:
        msg += "ğŸ’¹ *WDO* â†’ Compra\n"
    else:
        msg += "ğŸ’¹ *WIN* â†’ Venda\n"
    return msg

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 6) Envio assÃ­ncrono (com parse_mode)
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
async def send_telegram(text: str):
    try:
        await bot.send_message(
            chat_id=CHAT_ID,
            text=text,
            parse_mode=ParseMode.MARKDOWN
        )
    except TelegramError as e:
        print("Erro no Telegram:", e)

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 7) Loop principal assÃ­ncrono
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
async def main_loop():
    seen = set()
    while True:
        # Macro
        for ev in fetch_macro_events():
            if ev['link'] not in seen:
                seen.add(ev['link'])
                await send_telegram(format_event(ev))
                p0, p1 = validate_move('WDO=F', ev['pubDate'], 5*60)
                resultado = "âœ… Acertou!" if p1 > p0 else "âŒ Errou"
                await send_telegram(f"Validation: {p0:.2f} â†’ {p1:.2f} ({p1-p0:+.2f}) {resultado}")

        # NotÃ­cias
        for nf in fetch_rss_news():
            if nf['link'] not in seen:
                seen.add(nf['link'])
                texto = f"ğŸ“° [{nf['published'].strftime('%H:%M')}] {nf['title']}\n{nf['link']}"
                await send_telegram(texto)

        await asyncio.sleep(60)

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 8) Executar o loop de forma compatÃ­vel com Colab
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
await main_loop()

# Commented out IPython magic to ensure Python compatibility.
# %%javascript
# function clickConnect(){
#   document.querySelector("colab-connect-button").shadowRoot
#           .querySelector("#connect").click();
# }
# setInterval(clickConnect, 60*1000);
#